package com.quizhub.quizhub.controller;

import com.quizhub.quizhub.dto.*;
import com.quizhub.quizhub.model.Quiz;
import com.quizhub.quizhub.model.QuizVisibility;
import com.quizhub.quizhub.model.User;
import com.quizhub.quizhub.repository.QuizRepository;
import com.quizhub.quizhub.repository.UserRepository;
import com.quizhub.quizhub.service.FilteredQuizService;
import com.quizhub.quizhub.service.QuizService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/quizzes")
public class QuizController {

    private final QuizService quizService;

    public QuizController(QuizService quizService) {
        this.quizService = quizService;
    }

    @Autowired
    private FilteredQuizService filteredQuizService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private QuizRepository quizRepository;

    // Create a new quiz
//    @PostMapping("/create")
//    public ResponseEntity<Quiz> createQuiz(@RequestBody Quiz quiz) {
//        Quiz createdQuiz = quizService.saveQuiz(quiz);
//        return new ResponseEntity<>(createdQuiz, HttpStatus.CREATED);
//    }

    @PostMapping("/create")
    public ResponseEntity<Quiz> createQuiz(@RequestBody Quiz quiz, @RequestParam("userId") Long userId) {
        try {
            // Retrieve the user (educator) who is creating the quiz
            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new RuntimeException("User not found with ID: " + userId));
            // Set the generatedBy field
            quiz.setGeneratedBy(user);

            // Optionally, if your quiz model requires additional processing,
            // such as ensuring topics are saved as comma-separated string,
            // or calculating numberOfQuestions automatically,
            // perform that here.

            Quiz createdQuiz = quizService.saveQuiz(quiz);
            return new ResponseEntity<>(createdQuiz, HttpStatus.CREATED);
        } catch (Exception e) {
            e.printStackTrace();  // Log full error details for debugging
            return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // Get all quizzes generated by a specific user
    @GetMapping("/{userId}")
    public ResponseEntity<List<Quiz>> getQuizzesByUser(@PathVariable("userId") Long userId) {
        List<Quiz> quizzes = quizService.getQuizzesByUser(userId);
        return ResponseEntity.ok(quizzes);
    }

    // Get a specific quiz by its ID and user ID
    @GetMapping("/{id}/user/{userId}")
    public ResponseEntity<Quiz> getQuizByIdAndUser(@PathVariable("id") Long id, @PathVariable("userId") Long userId) {
        Optional<Quiz> quizOpt = quizService.getQuizByIdAndUser(id, userId);
        return quizOpt.map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    // Delete a quiz by its ID
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteQuiz(@PathVariable("id") Long id) {
        quizService.deleteQuiz(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Endpoint to create a filtered quiz.
     * Expects a JSON payload matching FilteredQuizRequest and a userId as a request parameter.
     *
     * Example request URL:
     * POST /quizzes/filtered?userId=123
     *
     * @param request the filter criteria.
     * @param userId the ID of the user generating the quiz.
     * @return the newly created Quiz entity.
     */
    @PostMapping("/filtered")
    public ResponseEntity<Quiz> createFilteredQuiz(@RequestBody FilteredQuizRequest request,
                                                   @RequestParam("userId") Long userId) {
        try {
            Quiz quiz = filteredQuizService.createFilteredQuiz(request, userId);
            return new ResponseEntity<>(quiz, HttpStatus.CREATED);
        } catch (Exception e) {
            // In production, log the error and return a meaningful message.
            return new ResponseEntity<>(null, HttpStatus.BAD_REQUEST);
        }
    }

    @GetMapping("/all")
    public ResponseEntity<List<BaseQuizDTO>> getAllQuizzes() {
        List<Quiz> quizzes = quizService.getAllQuizzes();
        List<BaseQuizDTO> quizDTOs = quizzes.stream().map(quiz -> {
            switch (quiz.getVisibility()) {
                case FILTERED:
                    return new FilteredQuizDTO(quiz);
                case PUBLIC:
                    return new PublicQuizDTO(quiz);
                case PRIVATE:
                    return new PrivateQuizDTO(quiz);
                default:
                    return new BaseQuizDTO(quiz);
            }
        }).toList();

        return ResponseEntity.ok(quizDTOs);
    }

    @GetMapping("/filtered/{userId}")
    public ResponseEntity<List<FilteredQuizDTO>> getFilteredQuizzesByUser(@PathVariable("userId") Long userId) {
        List<Quiz> quizzes = quizService.getFilteredQuizzesByUser(userId);
        List<FilteredQuizDTO> quizDTOs = quizzes.stream()
                .map(FilteredQuizDTO::new)
                .collect(Collectors.toList());
        return ResponseEntity.ok(quizDTOs);
    }

    @GetMapping("/details/{quizId}")
    public ResponseEntity<QuizDTO> getQuizDetails(@PathVariable("quizId") Long quizId) {
        Optional<QuizDTO> quizOpt = quizService.getQuizDTOById(quizId);
        return quizOpt.map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

//    these are for listing in the educators dashboard
    @GetMapping("/public/{userId}")
    public ResponseEntity<List<PublicQuizDTO>> getPublicQuizzesByUser(@PathVariable Long userId) {
        List<Quiz> quizzes = quizService.getQuizzesByUserAndVisibility(userId, QuizVisibility.PUBLIC);
        List<PublicQuizDTO> quizDTOs = quizzes.stream().map(PublicQuizDTO::new).collect(Collectors.toList());
        return ResponseEntity.ok(quizDTOs);
    }

    @GetMapping("/private/{userId}")
    public ResponseEntity<List<PrivateQuizDTO>> getPrivateQuizzesByUser(@PathVariable Long userId) {
        List<Quiz> quizzes = quizService.getQuizzesByUserAndVisibility(userId, QuizVisibility.PRIVATE);
        List<PrivateQuizDTO> quizDTOs = quizzes.stream().map(PrivateQuizDTO::new).collect(Collectors.toList());
        return ResponseEntity.ok(quizDTOs);
    }

    @GetMapping("/public")
    public ResponseEntity<List<PublicQuizDTO>> getAllPublicQuizzes() {
        List<Quiz> quizzes = quizService.getQuizzesByVisibility(QuizVisibility.PUBLIC);
        List<PublicQuizDTO> quizDTOs = quizzes.stream()
                .map(PublicQuizDTO::new)
                .collect(Collectors.toList());
        return ResponseEntity.ok(quizDTOs);
    }


    @GetMapping("/private")
    public ResponseEntity<PrivateQuizDTO> getPrivateQuizByCode(@RequestParam("code") String code) {
        Optional<Quiz> quizOpt = quizRepository.findByPrivateCode(code);
        if (quizOpt.isPresent() && quizOpt.get().getVisibility() == QuizVisibility.PRIVATE) {
            return ResponseEntity.ok(new PrivateQuizDTO(quizOpt.get()));
        } else {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

}
